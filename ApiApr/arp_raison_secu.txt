Cette partie utilise flask pour avoir un thread run qui lance la méthode api_apr
dès qu'une personne fait appel à l'adresse http://127.0.0.1:5000/api/arp.
Ceci permet d'assurer une continuité du service 24h/24h sans avoir à relancer le
serveur.

On utilise zmq pour communiquer avec le token dealer pour les mêmes raisons
qu'évoqué dans l'explication du token dealer.

On ne sait pas d'où vient le problème mais l'appel aux méthode de zmq font que
flask ne reboucle pas ni n'envoi le return en réponse (postman attend une
réponse sans jamais la recevoir alors que l'on atteint bien le return).
Le problème ne survient pas si l'on commente le contenu du premier if.

On utilise un timeout de 5 secondes pour la réception de la validation du token
par le token dealer donc le service n'est pas bloqué si le token dealer est down
mais celà implique aussi une disponibilité toutes les 5 secondes du service
le rendant peu réactif si plusieurs utilisateurs tente de demander la
ressource en même temps.

La ressource secrète se trouve en clair dans le code et donc si l'on obtient
l'accès au code, elle n'est plus vraiment secrète mais il faudrait dans tous
cas au moins trouver comment cacher la clef de déchiffrement car sinon chiffrer
tout en ayant la clef visible (avec le nom de l'algorithme de chiffrement en
import ou le code de déchiffrement dans un fichier du service) ne rend pas
la ressource plus confidentielle.